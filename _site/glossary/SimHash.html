<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>SimHash</title>
	<link rel="stylesheet" href="/assets/css/styles.css" />
</head>
<body>
<h1>SimHash</h1>

<p>a <a href="Locality%20sensitive%20hash%20function.html">Locality
sensitive hash function</a> scheme for <a
href="Cosine%20similarity.html">Cosine similarity</a>:</p>
<ul>
<li>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐠</mi><mn>1</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>𝐠</mi><mi>r</mi></msub><mo>∈</mo><msup><mi>ℝ</mi><mi>d</mi></msup></mrow><annotation encoding="application/x-tex">\mathbf{g}_1,...,\mathbf{g}_r \in \mathbb{R}^d</annotation></semantics></math>
be randomly chosen with each entry
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒩</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{N}(0,1)</annotation></semantics></math>.</li>
<li>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mo stretchy="false" form="prefix">{</mo><mo>−</mo><mn>1</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mi>r</mi></msup><mo>→</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>m</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">f : \{-1,1\}^r \rightarrow \{1,…,m\}</annotation></semantics></math>
be a <a href="Uniformly%20Random%20Hash%20Function.html">Uniformly Random
Hash Function</a>.</li>
<li>Define the LSH hash function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>:</mo><msup><mi>ℝ</mi><mi>d</mi></msup><mo>→</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>m</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">h: \mathbb{R}^d \rightarrow \{1,…,m\}</annotation></semantics></math>
as:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">[</mo><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">n</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mo stretchy="false" form="prefix">⟨</mo><msub><mi>𝐠</mi><mn>1</mn></msub><mo>,</mo><mi>x</mi><mo stretchy="false" form="postfix">⟩</mo><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">n</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mo stretchy="false" form="prefix">⟨</mo><msub><mi>𝐠</mi><mi>r</mi></msub><mo>,</mo><mi>x</mi><mo stretchy="false" form="postfix">⟩</mo><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">h(x) = f([\mathrm{sign}(\langle \mathbf{g}_1,x \rangle),...,\mathrm{sign}(\langle \mathbf{g}_r,x \rangle)])</annotation></semantics></math></li>
</ul>
<h2 id="proof">Proof</h2>
<p>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo>=</mo><mi>θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo>,</mo><mi>𝐲</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\theta = \theta(\mathbf{x},\mathbf{y})</annotation></semantics></math>.
Will show that (theorem to prove):
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">P</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">[</mo><mi>h</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>h</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐲</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mfrac><mi>θ</mi><mi>𝚷</mi></mfrac><mo>+</mo><mfrac><mn>1</mn><mi>m</mi></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathrm{Pr}[h(\mathbf{x}) = h(\mathbf{y})] = (1 − \frac{θ}{\mathbf{Π}}+\frac{1}{m})</annotation></semantics></math>
Intermediate result to show that:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mo>Pr</mo><mrow><mo stretchy="true" form="prefix">(</mo><mo stretchy="false" form="prefix">⟨</mo><mi>𝐠</mi><mo>,</mo><mi>𝐱</mi><mo stretchy="false" form="postfix">⟩</mo><mo>=</mo><mo stretchy="false" form="prefix">⟨</mo><mi>𝐠</mi><mo>,</mo><mi>𝐲</mi><mo stretchy="false" form="postfix">⟩</mo><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>1</mn><mo>−</mo><mfrac><mi>θ</mi><mi>π</mi></mfrac></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
\Pr( \langle \mathbf{g}, \mathbf{x} \rangle = \langle \mathbf{g},
\mathbf{y} \rangle )
= 1 - \frac{\theta}{\pi}
\end{align*}</annotation></semantics></math> Consider random vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐠</mi><annotation encoding="application/x-tex">\mathbf{g}</annotation></semantics></math>
and its hyperplane. Since it is drawn from the standard normal
distribution, the direction of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐠</mi><annotation encoding="application/x-tex">\mathbf{g}</annotation></semantics></math>
is uniformly distributed around the unit circle. Similarly, the
hyperplane is also uniformly distributed around the unit circle.
The <em>sign</em> of the inner
product <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><mi>𝐠</mi><mo>,</mo><mi>𝐱</mi><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\langle \mathbf{g},\mathbf{x} \rangle</annotation></semantics></math> specifies
which side of the
hyperplane <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐱</mi><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math> is
on. Intuitively, the probability
that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐱</mi><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐲</mi><annotation encoding="application/x-tex">\mathbf{y}</annotation></semantics></math> are
on the same side of the hyperplane is proportional to their angle.</p>
<p>The probability that they lie on <em>different</em> sides of the
hyperplane is the probability that the random hyperplane falls
between <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐱</mi><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐲</mi><annotation encoding="application/x-tex">\mathbf{y}</annotation></semantics></math> which
is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mrow><mn>2</mn><mi>θ</mi></mrow><mrow><mn>2</mn><mi>π</mi></mrow></mfrac><annotation encoding="application/x-tex">\frac{2\theta}{2\pi}</annotation></semantics></math>.
Then the probability that they lie on the <em>same</em> side of the
hyperplane
is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><mfrac><mi>θ</mi><mi>π</mi></mfrac></mrow><annotation encoding="application/x-tex">1−\frac{\theta}{\pi}</annotation></semantics></math>.</p>
<p>In higher dimensions, we can use the same intuition. There is always
some rotation
matrix <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐔</mi><annotation encoding="application/x-tex">\mathbf{U}</annotation></semantics></math> such
that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐔</mi><mi>𝐱</mi></mrow><annotation encoding="application/x-tex">\mathbf{Ux}</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐔</mi><mi>𝐲</mi></mrow><annotation encoding="application/x-tex">\mathbf{Uy}</annotation></semantics></math> are
spanned by the first two standard basis vectors and have the same cosine
similarity
as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐱</mi><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐲</mi><annotation encoding="application/x-tex">\mathbf{y}</annotation></semantics></math>.
Then we can apply the result in one dimension
to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐔</mi><mi>𝐱</mi></mrow><annotation encoding="application/x-tex">\mathbf{Ux}</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐔</mi><mi>𝐲</mi></mrow><annotation encoding="application/x-tex">\mathbf{Uy}</annotation></semantics></math>.</p>
<hr />
<p>SimHash can be tuned, just like our <a
href="MinHash%20(Broder,%201997).html">MinHash</a> based function for <a
href="Jaccard%20similarity.html">Jaccard similarity</a></p>
<ul>
<li>Suppose
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>g</mi><mi>r</mi></msub><mo>∈</mo><msup><mi>ℝ</mi><mi>d</mi></msup></mrow><annotation encoding="application/x-tex">g_1,…,g_r \in \mathbb{R}^d</annotation></semantics></math>
be randomly chosen with each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒩</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{N}(0,1)</annotation></semantics></math>.</li>
<li>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mo stretchy="false" form="prefix">{</mo><mo>−</mo><mn>1</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mi>r</mi></msup><mo>→</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>m</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">f: \{-1,1\}^r \rightarrow \{1,...,m\}</annotation></semantics></math>
be a <a href="Uniformly%20Random%20Hash%20Function.html">Uniformly Random
Hash Function</a></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>:</mo><msup><mi>ℝ</mi><mi>d</mi></msup><mo>→</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>m</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">h: \mathbb{R}^d \rightarrow \{1,…,m\}</annotation></semantics></math>
is defined</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">[</mo><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">n</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mo stretchy="false" form="prefix">⟨</mo><msub><mi>𝐠</mi><mn>1</mn></msub><mo>,</mo><mi>𝐱</mi><mo stretchy="false" form="postfix">⟩</mo><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">n</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mo stretchy="false" form="prefix">⟨</mo><msub><mi>𝐠</mi><mi>r</mi></msub><mo>,</mo><mi>𝐱</mi><mo stretchy="false" form="postfix">⟩</mo><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">h(\mathbf{x}) = f ([\mathrm{sign}(⟨\mathbf{g}_1, \mathbf{x}⟩), . . . , \mathrm{sign}(⟨\mathbf{g}_r, \mathbf{x}⟩)])</annotation></semantics></math>.</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">P</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">[</mo><mi>h</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo>=</mo><mi>h</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐲</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mfrac><mi>θ</mi><mi>𝚷</mi></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mi>r</mi></msup></mrow><annotation encoding="application/x-tex">\mathrm{Pr}[h(\mathbf{x}) == h(\mathbf{y})] = (1 − \frac{θ}{\mathbf{Π}})^r</annotation></semantics></math></li>
</ul>
<hr />
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>i</mi><mi>m</mi><mi>H</mi><mi>a</mi><mi>s</mi><mi>h</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">n</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mo stretchy="false" form="prefix">⟨</mo><mi>x</mi><mo>,</mo><mi>t</mi><mo stretchy="false" form="postfix">⟩</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">SimHash(x) = \mathrm{sign}(⟨x,t⟩)</annotation></semantics></math>
for a random vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>.</p>
<hr />
<p>see <a href="Hashing">Hashing</a></p>
<p>References:</p>
<ol type="1">
<li>M. S. Charikar, “Similarity estimation techniques from rounding
algorithms,” in <em>Proceedings of the thiry-fourth annual ACM symposium
on Theory of computing</em>, Montreal Quebec Canada: ACM, May 2002, pp.
380–388. doi: <a
href="https://doi.org/10.1145/509907.509965">10.1145/509907.509965</a>.</li>
<li><a
href="https://www.chrismusco.com/amlds2023/notes/lecture05.html#SimHash">https://www.chrismusco.com/amlds2023/notes/lecture05.html#SimHash</a></li>
<li><a
href="https://en.wikipedia.org/wiki/SimHash">https://en.wikipedia.org/wiki/SimHash</a></li>
<li><a
href="https://ferd.ca/simhashing-hopefully-made-simple.html">https://ferd.ca/simhashing-hopefully-made-simple.html</a></li>
<li><a
href="https://datascience.stackexchange.com/questions/6086/minhashing-vs-simhashing">https://datascience.stackexchange.com/questions/6086/minhashing-vs-simhashing</a></li>
<li><a
href="https://people.cs.umass.edu/~cmusco/CS514F20/slides/lecture8/lecture8Compressed.pdf">https://people.cs.umass.edu/~cmusco/CS514F20/slides/lecture8/lecture8Compressed.pdf</a></li>
<li><a
href="https://sumonbis.github.io/academic-project/simhash/">https://sumonbis.github.io/academic-project/simhash/</a></li>
<li><a
href="https://www.fromkk.com/posts/near-duplicate-with-simhash/">https://www.fromkk.com/posts/near-duplicate-with-simhash/</a></li>
</ol>
</body>
</html>
