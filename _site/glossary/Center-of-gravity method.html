<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Center-of-gravity method</title>
	<link rel="stylesheet" href="/assets/css/styles.css" />
</head>
<body>
<h1>Center-of-gravity method</h1>

<p>For convex set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒮</mi><mo>⊆</mo><msup><mi>ℝ</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\mathcal{S} \subseteq \mathbb{R}^n</annotation></semantics></math>,
convex function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><msup><mi>ℝ</mi><mi>n</mi></msup><mo>→</mo><mi>ℝ</mi></mrow><annotation encoding="application/x-tex">f: \mathbb{R}^n \rightarrow \mathbb{R}</annotation></semantics></math>,
we want to minimize
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(\mathbf{x})</annotation></semantics></math>
over
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐱</mi><mo>∈</mo><mi>𝒮</mi></mrow><annotation encoding="application/x-tex">\mathbf{x} \in \mathcal{S}</annotation></semantics></math></p>
<h2 id="algorithm">Algorithm:</h2>
<ul>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝒮</mi><mn>1</mn></msub><mo>=</mo><mi>𝒮</mi></mrow><annotation encoding="application/x-tex">\mathcal{S}_1=\mathcal{S}</annotation></semantics></math></li>
<li>For
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">t=1,…,T</annotation></semantics></math>:
<ul>
<li>at step
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>,
let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐜</mi><mi>t</mi></msub><mo>=</mo><mrow><mtext mathvariant="normal">center of gravity of </mtext><mspace width="0.333em"></mspace></mrow><msub><mi>𝒮</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">\mathbf{c}_t = \textrm{center of gravity of } \mathcal{S}_t</annotation></semantics></math>.</li>
<li>compute gradient
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∇</mi><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐜</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\nabla f(\mathbf{c}_t)</annotation></semantics></math>.</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ℋ</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>𝐱</mi><mo stretchy="false" form="prefix">|</mo><mo stretchy="false" form="prefix">⟨</mo><mi>∇</mi><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐜</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>𝐱</mi><mo>−</mo><msub><mi>𝐜</mi><mi>t</mi></msub><mo stretchy="false" form="postfix">⟩</mo><mo>≤</mo><mn>0</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\mathcal{H}= \{\mathbf{x}|\langle \nabla f(\mathbf{c}_t),\mathbf{x}-\mathbf{c}_t \rangle\leq 0\}</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝒮</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>𝒮</mi><mi>t</mi></msub><mo>∩</mo><mi>H</mi></mrow><annotation encoding="application/x-tex">\mathcal{S}_{t+1} = \mathcal{S}_t \cap H</annotation></semantics></math></li>
</ul></li>
<li>Return
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>𝐱</mi><mo accent="true">̂</mo></mover><mo>=</mo><mo>arg</mo><msub><mo>min</mo><mi>t</mi></msub><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐜</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{\mathbf{x}} = \arg \min_t f(\mathbf{c}_t)</annotation></semantics></math></li>
</ul>
<h2 id="proof">Proof</h2>
<p>By <a href="Grünbaum&#39;s%20theorem.html">Grünbaum's theorem</a>, cut
the volume of the search space by constant every step. #incomplete</p>
<hr />
<p>idea: minimizing convex function over convex set using “natural
plane-cutting method”</p>
<p>center of gravity of convex set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒮</mi><annotation encoding="application/x-tex">\mathcal{S}</annotation></semantics></math>
defined as:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><mfrac><mrow><msub><mo>∫</mo><mrow><mi>x</mi><mo>∈</mo><mi>𝒮</mi></mrow></msub><mi>x</mi><mspace width="0.167em"></mspace><mi>d</mi><mi>x</mi></mrow><mrow><mtext mathvariant="normal">vol</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝒮</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><mo>=</mo><mfrac><mrow><msub><mo>∫</mo><mrow><mi>x</mi><mo>∈</mo><mi>𝒮</mi></mrow></msub><mi>x</mi><mspace width="0.167em"></mspace><mi>d</mi><mi>x</mi></mrow><mrow><msub><mo>∫</mo><mrow><mi>x</mi><mo>∈</mo><mi>𝒮</mi></mrow></msub><mn>1</mn><mi>d</mi><mi>x</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">c = \frac{\int_{x \in \mathcal{S}} x \, dx}{\text{vol}(\mathcal{S})}
= \frac{\int_{x \in \mathcal{S}} x \, dx}{\int_{x \in \mathcal{S}} 1
dx}</annotation></semantics></math> Additionally, for two convex
sets <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒜</mi><annotation encoding="application/x-tex">\mathcal{A}</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℬ</mi><annotation encoding="application/x-tex">\mathcal{B}</annotation></semantics></math>,
the
intersection <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒜</mi><mo>∩</mo><mi>ℬ</mi></mrow><annotation encoding="application/x-tex">\mathcal{A} \cap \mathcal{B}</annotation></semantics></math> is
also convex. To see this, consider two
points <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐱</mi><mo>,</mo><mi>𝐲</mi><mo>∈</mo><mi>𝒜</mi><mo>∩</mo><mi>ℬ</mi></mrow><annotation encoding="application/x-tex">\mathbf{x}, \mathbf{y} \in \mathcal{A} \cap \mathcal{B}</annotation></semantics></math>.
Then for
any <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>∈</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\lambda \in (0,1)</annotation></semantics></math>,
we have
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>𝐱</mi><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>λ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>𝐲</mi><mo>∈</mo><mi>𝒜</mi></mrow><annotation encoding="application/x-tex">\lambda \mathbf{x} + (1-\lambda) \mathbf{y} \in \mathcal{A}</annotation></semantics></math></p>
<p>because
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐱</mi><mo>,</mo><mi>𝐲</mi></mrow><annotation encoding="application/x-tex">\mathbf{x},\mathbf{y}</annotation></semantics></math>
are in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒜</mi><annotation encoding="application/x-tex">\mathcal{A}</annotation></semantics></math>
and
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>𝐱</mi><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>λ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>𝐲</mi><mo>∈</mo><mi>ℬ</mi></mrow><annotation encoding="application/x-tex">\lambda \mathbf{x} + (1-\lambda) \mathbf{y} \in \mathcal{B}</annotation></semantics></math></p>
<p>because
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐱</mi><mo>,</mo><mi>𝐲</mi></mrow><annotation encoding="application/x-tex">\mathbf{x},\mathbf{y}</annotation></semantics></math>
are in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℬ</mi><annotation encoding="application/x-tex">\mathcal{B}</annotation></semantics></math>.</p>
<hr />
<p>Drawbacks: computing centroid in general is hard, #P-hard when
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒮</mi><annotation encoding="application/x-tex">\mathcal{S}</annotation></semantics></math>
is intersection of half-spaces (polytope)</p>
<p>…</p>
<p>Hence, consider <a href="Ellipsoid%20method.html">Ellipsoid
method</a></p>
<hr />
<p>References:</p>
<ol type="1">
<li>A. Y. Levin. On an algorithm for the minimization of convex
functions over convex functions. <em>Soviet Mathematics Doklady</em>,
160(1244–1247), 1965. <a
href="https://www.mathnet.ru/php/archive.phtml?wshow=paper&amp;jrnid=dan&amp;paperid=30770&amp;option_lang=eng">https://www.mathnet.ru/php/archive.phtml?wshow=paper&amp;jrnid=dan&amp;paperid=30770&amp;option_lang=eng</a></li>
<li>D. J. Newman. Location of the maximum on unimodal surfaces. <em>J.
ACM</em>, 12(3):395–398, July 1965.</li>
<li><a
href="https://www.chrismusco.com/amlds2023/notes/lecture09.html">https://www.chrismusco.com/amlds2023/notes/lecture09.html</a></li>
<li><a
href="https://www.cs.cmu.edu/~anupamg/advalgos17/scribes/lec16.pdf">https://www.cs.cmu.edu/~anupamg/advalgos17/scribes/lec16.pdf</a></li>
</ol>
</body>
</html>
