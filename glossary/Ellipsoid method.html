<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Ellipsoid method</title>
	<link rel="stylesheet" href="/styles.css" />
</head>
<body>
<h1>Ellipsoid method</h1>

<p>c.f. <a href="Center-of-gravity%20method.html">Center-of-gravity
method</a></p>
<p>Consider a more slightly general problem. Given <a
href="convex%20set.html">convex set</a>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒦</mi><annotation encoding="application/x-tex">\mathcal{K}</annotation></semantics></math>
via access to <a href="Separation%20oracle.html">separation oracle</a>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>S</mi><mi>𝒦</mi></msub><annotation encoding="application/x-tex">S_\mathcal{K}</annotation></semantics></math>
for the set, we want to determine if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒦</mi><annotation encoding="application/x-tex">\mathcal{K}</annotation></semantics></math>
is empty or, otherwise, return any point
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐱</mi><mo>∈</mo><mi>𝒦</mi></mrow><annotation encoding="application/x-tex">\mathbf{x} \in \mathcal{K}</annotation></semantics></math>.</p>
<p>The hyperplane is parameterized by a normal vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐚</mi><annotation encoding="application/x-tex">\mathbf{a}</annotation></semantics></math>
and offset
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>
so
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ℋ</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>𝐱</mi><mo>:</mo><mo stretchy="false" form="prefix">⟨</mo><mi>𝐚</mi><mo>,</mo><mi>𝐱</mi><mo stretchy="false" form="postfix">⟩</mo><mo>≤</mo><mi>c</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\mathcal{H} = \{\mathbf{x}: \langle \mathbf{a},\mathbf{x}\rangle \leq c \}</annotation></semantics></math>.</p>
<p>#incomplete</p>
<h2 id="theorem-khachiyan-1979">Theorem (Khachiyan, 1979)</h2>
<p>Assume
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">n = d</annotation></semantics></math>.
The ellipsoid method solves any linear program with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>-bit
integer valued constraints exactly in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>n</mi><mn>4</mn></msup><mi>L</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(n^4 L)</annotation></semantics></math>
time.</p>
<hr />
<h2 id="separation-oracle-example">Separation Oracle Example</h2>
<p>#incomplete</p>
<hr />
<p><strong>Basic ellipsoid method.</strong> The basic ellipsoid
algorithm is:</p>
<ul>
<li><em>Ellipsoid method</em></li>
<li><strong>given</strong> an initial ellipsoid
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>P</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo>,</mo><msup><mi>x</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(P^{(0)}, x^{(0)})</annotation></semantics></math>
containing a minimizer of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>.</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>:=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">k := 0</annotation></semantics></math>.</li>
<li><strong>repeat</strong>
<ul>
<li>Compute a subgradient:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>∈</mo><mi>∂</mi><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>x</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">g(k) ∈ ∂f (x^{(k)})</annotation></semantics></math>.</li>
<li>Normalize the subgradient:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>g</mi><mo accent="true">̃</mo></mover><mo>:=</mo><mfrac><mn>1</mn><msqrt><mrow><msup><mi>g</mi><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>T</mi></mrow></msup><msup><mi>P</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><msup><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup></mrow></msqrt></mfrac><msup><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">\tilde{g} := \frac{1}{\sqrt{g^{(k)T} P^{(k)}g^{(k)}}} g^{(k)}</annotation></semantics></math>.</li>
<li>Update ellipsoid center:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo>:=</mo><msup><mi>x</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo>−</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><msup><mi>P</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mover><mi>g</mi><mo accent="true">̃</mo></mover></mrow><annotation encoding="application/x-tex">x^{(k+1)} := x^{(k)} − \frac{1}{n+1} P^{(k)} \tilde{g}</annotation></semantics></math>.</li>
<li>Update ellipsoid shape:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>P</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo>:=</mo><mfrac><msup><mi>n</mi><mn>2</mn></msup><mrow><msup><mi>n</mi><mn>2</mn></msup><mo>−</mo><mn>1</mn></mrow></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>P</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo>−</mo><mfrac><mn>2</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><msup><mi>P</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mover><mi>g</mi><mo accent="true">̃</mo></mover><msup><mover><mi>g</mi><mo accent="true">̃</mo></mover><mi>T</mi></msup><msup><mi>P</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">P^{(k+1)} := \frac{n^2}{n^2 -1}\left( P^{(k)}-\frac{2}{n+1}P^{(k)}\tilde{g}\tilde{g}^T P^{(k)}\right)</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>:=</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k := k + 1</annotation></semantics></math>.</li>
</ul></li>
</ul>
<p>The ellipsoid method is not a descent method, so we keep track of the
best point found. We define
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>f</mi><mrow><mi>b</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mo>=</mo><munder><mo>min</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>k</mi></mrow></munder><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>x</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f^{(k)}_{best}=\min_{j=0,...,k} f(x^{(j)})</annotation></semantics></math></p>
<hr />
<p>References:</p>
<ol type="1">
<li>Khachiyan, L. G. 1979. "A Polynomial Algorithm in Linear
Programming". <em>Doklady Akademii Nauk SSSR</em> 244, 1093-1096
(translated in <em>Soviet Mathematics Doklady</em> 20, 191-194,
1979).</li>
<li><a
href="https://www.nytimes.com/1979/11/07/archives/a-soviet-discovery-rocks-world-of-mathematics-russians-surprise.html">https://www.nytimes.com/1979/11/07/archives/a-soviet-discovery-rocks-world-of-mathematics-russians-surprise.html</a></li>
<li><a
href="https://www.chrismusco.com/amlds2023/notes/lecture09.html#Ellipsoid_Method">https://www.chrismusco.com/amlds2023/notes/lecture09.html#Ellipsoid_Method</a></li>
<li><a
href="https://www.cs.princeton.edu/courses/archive/fall18/cos521/Lectures/lec16.pdf">https://www.cs.princeton.edu/courses/archive/fall18/cos521/Lectures/lec16.pdf</a></li>
<li><a
href="https://web.stanford.edu/class/ee364b/lectures/ellipsoid_method_notes.pdf">https://web.stanford.edu/class/ee364b/lectures/ellipsoid_method_notes.pdf</a></li>
<li><a
href="https://www.cs.ubc.ca/~nickhar/W13/Lecture4.pdf">https://www.cs.ubc.ca/~nickhar/W13/Lecture4.pdf</a></li>
</ol>
</body>
</html>
